<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Case Studies in Neural Data Analysis</title>
  <meta name="description" content="# Analysis of coupled rhythms *for the practicing neuroscientist*+++    _**Synopsis**_ **Data:** 1 s of ECoG data sampled at 500 Hz from two electrodes for 1...">

  <link rel="canonical" href="https://mark-kramer.github.io/Case-Studies-Python/content/05/the-cross-covariance-and-coherence.html">
  <link rel="alternate" type="application/rss+xml" title="Case Studies in Neural Data Analysis" href="https://mark-kramer.github.io/Case-Studies-Python/feed.xml">

  <meta property="og:url"         content="https://mark-kramer.github.io/Case-Studies-Python/content/05/the-cross-covariance-and-coherence.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Case Studies in Neural Data Analysis" />
<meta property="og:description" content="# Analysis of coupled rhythms *for the practicing neuroscientist*+++    _**Synopsis**_ **Data:** 1 s of ECoG data sampled at 500 Hz from two electrodes for 1..." />
<meta property="og:image"       content="https://mark-kramer.github.io/Case-Studies-Python/images/logo/logo.png" />

<meta name="twitter:card" content="summary">


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage": "https://mark-kramer.github.io/Case-Studies-Python/content/05/the-cross-covariance-and-coherence.html",
  "headline": "Case Studies in Neural Data Analysis",
  "datePublished": "2020-06-12T15:51:41-04:00",
  "dateModified": "2020-06-12T15:51:41-04:00",
  "description": "# Analysis of coupled rhythms *for the practicing neuroscientist*+++    _**Synopsis**_ **Data:** 1 s of ECoG data sampled at 500 Hz from two electrodes for 1...",
  "author": {
    "@type": "Person",
    "name": "Mark Kramer and Uri Eden"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mark-kramer.github.io/Case-Studies-Python",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://mark-kramer.github.io/Case-Studies-Python",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/Case-Studies-Python/assets/css/styles.css">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/Case-Studies-Python/images/logo/favicon.ico">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<!-- (mostly) copied from nbconvert configuration -->
<!-- https://github.com/jupyter/nbconvert/blob/master/nbconvert/templates/html/mathjax.tpl -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true },
    },
    
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML' async></script>


  <!-- DOM updating function -->
  <script src="/Case-Studies-Python/assets/js/page/dom-update.js"></script>

  <!-- Selectors for elements on the page -->
  <script src="/Case-Studies-Python/assets/js/page/documentSelectors.js"></script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = '/Case-Studies-Python';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js" async></script>
  <script src="/Case-Studies-Python/assets/js/page/anchors.js" async></script>

  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->


<!-- Display Thebelab button in each code cell -->
<script>
/**
 * Set up thebelab button for code blocks
 */

const thebelabCellButton = id =>
  `<a id="thebelab-cell-button-${id}" class="btn thebebtn o-tooltip--left" data-tooltip="Interactive Mode">
    <img src="/Case-Studies-Python/assets/images/edit-button.svg" alt="Start thebelab interactive mode">
  </a>`


const addThebelabButtonToCodeCells =  () => {

  const codeCells = document.querySelectorAll('div.input_area > div.highlight:not(.output) pre')
  codeCells.forEach((codeCell, index) => {
    const id = codeCellId(index)
    codeCell.setAttribute('id', id)
    if (document.getElementById("thebelab-cell-button-" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', thebelabCellButton(id));
    }
  })
}

initFunction(addThebelabButtonToCodeCells);
</script>


<script src="https://unpkg.com/thebelab@latest/lib/index.js" async></script>
<script>
    /**
     * Add attributes to Thebelab blocks
     */

    const initThebelab = () => {
        const addThebelabToCodeCells = () => {
            console.log("Adding thebelab to code cells...");
            // If Thebelab hasn't loaded, wait a bit and try again. This
            // happens because we load ClipboardJS asynchronously.
            if (window.thebelab === undefined) {
                setTimeout(addThebelabToCodeCells, 250)
            return
            }

            // If we already detect a Thebelab cell, don't re-run
            if (document.querySelectorAll('div.thebelab-cell').length > 0) {
                return;
            }

            // Find all code cells, replace with Thebelab interactive code cells
            const codeCells = document.querySelectorAll('.input_area pre')
            codeCells.forEach((codeCell, index) => {
                const id = codeCellId(index)

                // Clean up the language to make it work w/ CodeMirror and add it to the cell
                dataLanguage = ""
                dataLanguage = detectLanguage(dataLanguage);
                codeCell.setAttribute('data-language', dataLanguage)
                codeCell.setAttribute('data-executable', 'true')

                // If the code cell is hidden, show it
                var inputCheckbox = document.querySelector(`input#hidebtn${codeCell.id}`);
                if (inputCheckbox !== null) {
                    setCodeCellVisibility(inputCheckbox, 'visible');
                }
            });

            // Remove the event listener from the page so keyboard press doesn't
            // Change page
            document.removeEventListener('keydown', initPageNav)
            keyboardListener = false;

            // Init thebelab
            thebelab.bootstrap();

            // Remove copy buttons since they won't work anymore
            const copyAndThebeButtons = document.querySelectorAll('.copybtn, .thebebtn')
            copyAndThebeButtons.forEach((button, index) => {
                button.remove();
            });

            // Remove outputs since they'll be stale
            const outputs = document.querySelectorAll('.output *, .output')
            outputs.forEach((output, index) => {
                output.remove();
            });

            // Find any cells with an initialization tag and ask ThebeLab to run them when ready
            var thebeInitCells = document.querySelectorAll('div.tag_thebelab-init');
            thebeInitCells.forEach((cell) => {
                console.log("Initializing ThebeLab with cell: " + cell.id);
                cell.querySelector('.thebelab-run-button').click();
            });
        }

        // Add event listener for the function to modify code cells
        const thebelabButtons = document.querySelectorAll('[id^=thebelab], [id$=thebelab]')
        thebelabButtons.forEach((thebelabButton,index) => {
            if (thebelabButton === null) {
                setTimeout(initThebelab, 250)
                return
            };
            thebelabButton.addEventListener('click', addThebelabToCodeCells);
        });
    }

    // Initialize Thebelab
    initFunction(initThebelab);

// Helper function to munge the language name
var detectLanguage = (language) => {
    if (language.indexOf('python') > -1) {
        language = "python";
    }
    return language;
}
</script>



  <!-- Load the auto-generating TOC (non-async otherwise the TOC won't load w/ turbolinks) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.8.1/tocbot.min.js" async></script>
  <script src="/Case-Studies-Python/assets/js/page/tocbot.js"></script>

  <!-- Google analytics -->
  


  <!-- Clipboard copy button -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script>

  <!-- Load custom website scripts -->
  <script src="/Case-Studies-Python/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/Case-Studies-Python/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/Case-Studies-Python/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  
<script>
/**
  * To auto-embed hub URLs in interact links if given in a RESTful fashion
 */

function getJsonFromUrl(url) {
  var query = url.split('?');
  if (query.length < 2) {
    // No queries so just return false
    return false;
  }
  query = query[1];
  // Collect REST params into a dictionary
  var result = {};
  query.split("&").forEach(function(part) {
    var item = part.split("=");
    result[item[0]] = decodeURIComponent(item[1]);
  });
  return result;
}
    
function dict2param(dict) {
    params = Object.keys(dict).map(function(k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(dict[k])
    });
    return params.join('&')
}

// Parse a Binder URL, converting it to the string needed for JupyterHub
function binder2Jupyterhub(url) {
  newUrl = {};
  parts = url.split('v2/gh/')[1];
  // Grab the base repo information
  repoinfo = parts.split('?')[0];
  var [org, repo, ref] = repoinfo.split('/');
  newUrl['repo'] = ['https://github.com', org, repo].join('/');
  newUrl['branch'] = ref
  // Grab extra parameters passed
  params = getJsonFromUrl(url);
  if (params['filepath'] !== undefined) {
    newUrl['subPath'] = params['filepath']
  }
  return dict2param(newUrl);
}

// Filter out potentially unsafe characters to prevent xss
function safeUrl(url)
{
   return String(encodeURIComponent(url))
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}

function addParamToInternalLinks(hub) {
  var links = document.querySelectorAll("a").forEach(function(link) {
    var href = link.href;
    // If the link is an internal link...
    if (href.search("https://mark-kramer.github.io") !== -1 || href.startsWith('/') || href.search("127.0.0.1:") !== -1) {
      // Assume we're an internal link, add the hub param to it
      var params = getJsonFromUrl(href);
      if (params !== false) {
        // We have REST params, so append a new one
        params['jupyterhub'] = hub;
      } else {
        // Create the REST params
        params = {'jupyterhub': hub};
      }
      // Update the link
      var newHref = href.split('?')[0] + '?' + dict2param(params);
      link.setAttribute('href', decodeURIComponent(newHref));
    }
  });
  return false;
}


// Update interact links
function updateInteractLink() {
    // hack to make this work since it expects a ? in the URL
    rest = getJsonFromUrl("?" + location.search.substr(1));
    jupyterHubUrl = rest['jupyterhub'];
    var hubType = null;
    var hubUrl = null;
    if (jupyterHubUrl !== undefined) {
      hubType = 'jupyterhub';
      hubUrl = jupyterHubUrl;
    }

    if (hubType !== null) {
      // Sanitize the hubUrl
      hubUrl = safeUrl(hubUrl);

      // Add HTTP text if omitted
      if (hubUrl.indexOf('http') < 0) {hubUrl = 'http://' + hubUrl;}
      var interactButtons = document.querySelectorAll("button.interact-button")
      var lastButton = interactButtons[interactButtons.length-1];
      var link = lastButton.parentElement;

      // If we've already run this, skip the link updating
      if (link.nextElementSibling !== null) {
        return;
      }

      // Update the link and add context div
      var href = link.getAttribute('href');
      if (lastButton.id === 'interact-button-binder') {
        // If binder links exist, we need to re-work them for jupyterhub
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // If localhost, assume we're working from a local Jupyter server and remove `/hub`
          first = [hubUrl, 'git-sync'].join('/')
        } else {
          first = [hubUrl, 'hub', 'user-redirect', 'git-sync'].join('/')
        }
        href = first + '?' + binder2Jupyterhub(href);
      } else {
        // If interact button isn't binderhub, assume it's jupyterhub
        // If JupyterHub links, we only need to replace the hub url
        href = href.replace("", hubUrl);
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // Assume we're working from a local Jupyter server and remove `/hub`
          href = href.replace("/hub/user-redirect", "");
        }
      }
      link.setAttribute('href', decodeURIComponent(href));

      // Add text after interact link saying where we're launching
      hubUrlNoHttp = decodeURIComponent(hubUrl).replace('http://', '').replace('https://', '');
      link.insertAdjacentHTML('afterend', '<div class="interact-context">on ' + hubUrlNoHttp + '</div>');

      // Update internal links so we retain the hub url
      addParamToInternalLinks(hubUrl);
    }
}

runWhenDOMLoaded(updateInteractLink)
document.addEventListener('turbolinks:load', updateInteractLink)
</script>


  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.6/lunr.min.js" async></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>

  <!-- Load JS that depends on site variables -->
  <script src="/Case-Studies-Python/assets/js/page/copy-button.js" async></script>

  <!-- Hide cell code -->
  <script src="/Case-Studies-Python/assets/js/page/hide-cell.js" async></script>

  <!-- Printing the screen -->
  <!-- Include nbinteract for interactive widgets -->
<script src="https://printjs-4de6.kxcdn.com/print.min.js" async></script>
<script>
printContent = () => {
    // MathJax displays a second version of any math for assistive devices etc.
    // This prevents double-rendering in the PDF output.
    var ignoreAssistList = [];
    assistives = document.querySelectorAll('.MathJax_Display span.MJX_Assistive_MathML').forEach((element, index) => {
        var thisId = 'MathJax-assistive-' + index.toString();
        element.setAttribute('id', thisId);
        ignoreAssistList.push(thisId)
    });

    // Print the actual content object
    printJS({
        printable: 'textbook_content',
        type: 'html',
        css: "/Case-Studies-Python/assets/css/styles.css",
        style: "#textbook_content {padding-top: 40px};",
        scanStyles: false,
        targetStyles: ["*"],
        ignoreElements: ignoreAssistList,
        documentTitle: "Made with Jupyter Book"
    })
};

initPrint = () => {
    document.querySelector('#interact-button-print').addEventListener('click', printContent)
}

initFunction(initPrint)
</script>

</head>

  <body>
    <!-- Include the ThebeLab config so it gets reloaded on each page -->
    <script type="text/x-thebe-config">{
    requestKernel: true,
    binderOptions: {
    repo: "mark-kramer/Case-Studies-Python",
    ref: "master",
    },
    codeMirrorConfig: {
    theme: "abcdef",
    mode: "python"
    },
    kernelOptions: {
    kernelName: "python3",
    path: ""
    }
}
</script>

    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  <a href="https://mitpress.mit.edu/books/case-studies-neural-data-analysis" target="_blank" rel="noopener noreferrer"><img src="/Case-Studies-Python/images/logo/logo.png" class="textbook_logo" id="sidebar-logo" alt="textbook logo" data-turbolinks-permanent></a>
  <h2 class="c-sidebar__title">Case Studies in Neural Data Analysis</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/intro">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/intro.html">
          
          Home
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      
        <li class="c-sidebar__divider">
        
      
      
        <li><h2 class="c-sidebar__title">Contents</h2></li>
        
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/01/introduction-to-python">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/01/introduction-to-python.html">
          
            1.
          
          Introduction to Python
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/02/the-event-related-potential">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/02/the-event-related-potential.html">
          
            2.
          
          The Event-Related Potential
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/03/the-power-spectrum-part-1">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/03/the-power-spectrum-part-1.html">
          
            3.
          
          The Power Spectrum (Part 1)
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/04/ecog-rhythms">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/04/ecog-rhythms.html">
          
            4.
          
          The Power Spectrum (Part 2)
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/05/the-cross-covariance-and-coherence">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/05/the-cross-covariance-and-coherence.html">
          
            5.
          
          The Cross Covariance and Coherence
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/06/filtering-scalp-eeg">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/06/filtering-scalp-eeg.html">
          
            6.
          
          Filtering Field Data
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/07/cross-frequency-coupling">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/07/cross-frequency-coupling.html">
          
            7.
          
          Cross Frequency Coupling
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/08/basic-visualizations-and-descriptive-statistics-of-spike-train-data">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/08/basic-visualizations-and-descriptive-statistics-of-spike-train-data.html">
          
            8.
          
          Basic Visualizations and Descriptive Statistics of Spike Train Data
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/09/point-process-glms">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/09/point-process-glms.html">
          
            9.
          
          Modeling place Fields with Point Process Generalized Linear Models
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/10/spiking-rhythms">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/10/spiking-rhythms.html">
          
            10.
          
          Analysis of Rhythmic Spiking in the Subthalamic Nucleus During a Movement Task
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/11/spike-field-coherence">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/11/spike-field-coherence.html">
          
            11.
          
          Analysis of Spike-Field Coherence
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      
        <li class="c-sidebar__divider">
        
      
      
        <li><h2 class="c-sidebar__title">Appendices</h2></li>
        
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/A01/backprop">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/A01/backprop.html">
          
            12.
          
          Backpropagation
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/A02/HH">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/A02/HH.html">
          
            13.
          
          Hodgkin Huxley Model
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/A03/LIF">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/A03/LIF.html">
          
            14.
          
          Integrate and Fire Model
        </a>
      </li>

      
      

      

      
      

      

      
    
      
      

      
      
      
      

      
      
      <li class="c-sidebar__chapter" data-url="/A04/perceptron">
        <a class="c-sidebar__entry" href="/Case-Studies-Python/A04/perceptron.html">
          
            15.
          
          Training a Perceptron
        </a>
      </li>

      
      

      

      
      

      

      
    
  </ul>
  <p class="sidebar_footer">Powered by <a href="https://github.com/jupyter/jupyter-book" target="_blank" rel="noopener noreferrer">Jupyter Book</a></p>
</nav>

      
      <div class="c-topbar" id="top-navbar">
  <!-- We show the sidebar by default so we use .is-active -->
  <div class="c-topbar__buttons">
    <button id="js-sidebar-toggle" class="hamburger hamburger--arrowalt is-active">
      <span class="hamburger-box">
        <span class="hamburger-inner"></span>
      </span>
    </button>
    <div class="buttons">
<div class="download-buttons-dropdown">
    <button id="dropdown-button-trigger" class="interact-button"><img src="/Case-Studies-Python/assets/images/download-solid.svg" alt="Download"></button>
    <div class="download-buttons">
        
        <a id="interact-button-print"><button id="interact-button-download" class="interact-button">.pdf</button></a>
    </div>
</div>


</div>

  </div>
  <!-- Empty sidebar placeholder that we'll auto-fill with javascript -->
  <aside class="sidebar__right">
    <header><h4 class="nav__title">
<img src="/Case-Studies-Python/assets/images/list-solid.svg" alt="Search">   On this page</h4></header>
    <nav class="onthispage">
    </nav>
  </aside>
  <a href="/Case-Studies-Python/search.html" class="topbar-right-button" id="search-button">
    <img src="/Case-Studies-Python/assets/images/search-solid.svg" alt="Search">
  </a>
</div>

      <main class="c-textbook__page" tabindex="-1">
            <div class="c-textbook__content" id="textbook_content">
              <p><a id="introduction"></a><a id="top"></a></p>
<h1 id="analysis-of-coupled-rhythms-for-the-practicing-neuroscientist">Analysis of coupled rhythms <em>for the practicing neuroscientist</em>
</h1>

<p>+++</p>

<div class="question">

  <p><em><strong>Synopsis</strong></em></p>

  <p><strong>Data:</strong> 1 s of ECoG data sampled at 500 Hz from two electrodes for 100 trials.</p>

  <p><strong>Goal:</strong> Characterize the coupling of rhythmic activity between the two electrodes.</p>

  <p><strong>Tools:</strong> Fourier transform, spectrum, amplitude, coherence, phase.</p>

</div>

<p>+++</p>

<ul>
  <li><a href="#background">Background</a></li>
  <li><a href="#case-study-data">Case Study Data</a></li>
  <li>
<a href="#data-analysis">Data Analysis</a>
    <ul>
      <li><a href="#visual-inspection">Visual Inspection</a></li>
      <li><a href="#Autocovariance-and-Cross-covariance">Autocovariance and Cross-covariance</a></li>
      <li><a href="#Trial-Averaged-Spectrum">Trial-Averaged Spectrum</a></li>
    </ul>
  </li>
  <li>
<a href="#sec:coherence">Introduction to the Coherence</a>
    <ul>
      <li><a href="#Simple_Scenario_1">Simple Scenario 1: Phases align across trials</a></li>
      <li><a href="#Simple_Scenario_2">Simple Scenario 2: Phases are random across trials</a></li>
      <li><a href="#Summary_of_the_coherence">Summary of the coherence</a></li>
    </ul>
  </li>
  <li><a href="#cc_and_cs">Cross-Covariance and Cross-Spectrum</a></li>
  <li>
<a href="#computing_coherence">Computing the Coherence</a>
    <ul>
      <li><a href="#Visualizing_the_Phase_Difference">Visualizing the Phase Difference across Trials</a></li>
      <li><a href="#single_trial_coherence">Single-Trial Coherence</a></li>
    </ul>
  </li>
  <li><a href="#Relation_between_Statistical_Modeling_and_Coherence">Relation between Statistical Modeling and Coherence</a></li>
  <li><a href="#summary">Summary</a></li>
</ul>

<p>+++</p>

<h2 id="on-ramp-computing-the-coherence-in-python">On-ramp: computing the coherence in Python</h2>
<p>We begin this module with an “<em>on-ramp</em>” to analysis. The purpose of this on-ramp is to introduce you immediately to a core concept in this module: how to compute the coherence in Python. You may not understand all aspects of the program here, but that’s not the point. Instead, the purpose of this on-ramp is to illustrate what <em>can</em> be done. Our advice is to simply run the code below and see what happens …</p>

<p>```{code-cell} ipython3</p>
<h1 id="import-our-favorite-functions-and-modules">Import our favorite functions and modules</h1>
<p>from scipy.io import loadmat                    # To load .mat files
import matplotlib.pyplot as plt                 # Load plotting functions
from pylab import *                             # Import plotting functions
from numpy import *                             # Import numerical functions
from IPython.core.pylabtools import figsize     # Allow us to change figure sizes
from IPython.core.display import HTML           # Package for manipulating appearance of notebooks
from IPython.lib.display import YouTubeVideo    # Package for displaying YouTube videos</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
```{code-cell} ipython3
# Import tools for the chapter
from numpy.fft import fft, rfft, rfftfreq
figsize(12, 3)  # Default to wide figs
</code></pre></div></div>

<p>```{code-cell} ipython3
data = loadmat(‘ECoG-1.mat’)  # Load the data,
E1 = data[‘E1’]  # … from the first electrode,
E2 = data[‘E2’]  # … and from the second electrode.
t = data[‘t’][0]  # Load the time axis,
dt = t[1] - t[0]  # … to get the sampling interval,
T = t[-1]  # … and the total time of the recording.
N = E1.shape[1]  # Determine the number of sample points per trial
scale = 2 * dt**2 / T  # Scaling constant</p>

<h1 id="compute-the-fourier-transforms">Compute the Fourier transforms</h1>
<p>xf = np.array([rfft(x - x.mean()) for x in E1])  # … for each trial in E1
yf = np.array([rfft(y - y.mean()) for y in E2])  # … and each trial in E2</p>

<h1 id="compute-the-spectra">Compute the spectra</h1>
<p>Sxx = scale * (xf * xf.conj()).mean(0)  # Spectrum of E1 trials
Syy = scale * (yf * yf.conj()).mean(0)  # … and E2 trials
Sxy = scale * (xf * yf.conj()).mean(0)  # … and the cross spectrum</p>

<h1 id="compute-the-coherence">Compute the coherence.</h1>
<p>cohr = abs(Sxy) / (np.sqrt(Sxx) * np.sqrt(Syy))</p>

<p>f = rfftfreq(N, dt)  # Define a frequency axis.
plot(f, cohr.real)  # Plot coherence vs frequency,
xlim([0, 50])  # … in a chosen frequency range,
ylim([0, 1])  # … with y-axis scaled,
xlabel(‘Frequency [Hz]’)  # … and with axes labeled.
ylabel(‘Coherence’)
title(‘Coherence between two electrodes’)
show()</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;div class="question"&gt;

**Q:** Try to read the code above. Can you see how it loads data, computes the coherence, and then plots the results?

**A:** If you've never computed the coherence before, that's an especially difficult question. Please continue on to learn this **and more**!

&lt;/div&gt;


## Introduction


### Background &lt;a class="anchor" id="background"&gt;&lt;/a&gt;


In most of the other modules, we focused on field data recorded from a single electrode at the scalp (EEG) or cortical (ECoG) surface. However, typical brain voltage recordings consist of multiple electrodes. For example, the standard EEG recording consists of [21 electrodes](https://tinyurl.com/yczt58e5) spaced across the scalp surface, and sometimes many more. The number of electrodes utilized in invasive ECoG recordings also range from a handful of contacts to over 100 implanted electrodes. In this module, we continue our study of field data recorded from the cortical surface but now consider ECoG data recorded simultaneously from two electrodes during a task.



[Return to top](#introduction)


### Case Study Data &lt;a class="anchor" id="case-study-data"&gt;&lt;a/&gt;
We conside a patient with epilepsy admitted to the hospital for [resective surgery](https://www.ncbi.nlm.nih.gov/pubmed/25602999). As part of her routine clinical workup before resective surgery, numerous electrodes were implanted [directly on the cortical surface](https://en.wikipedia.org/wiki/Electrocorticography). The purpose of this invasive recording procedure was to monitor and localize her seizures for eventual surgical treatment. During this recording procedure, in which electrocorticogram (ECoG) electrodes were implanted and recordings performed for one week, the patient volunteered to participate in an auditory task study administered by a collaborating researcher. The task required the patient to listen to individual phonemes through headphones and respond with a button click whenever she heard the [phoneme](http://www.jneurosci.org/content/30/49/16643) “ba” (the other phonemes were different, e.g., “pa,” ”ma”). The tone presentation was repeated 100 times, and her ECoG recorded (sampling rate 500 Hz) from two cortical electrodes over the auditory brain area for 1 s.


[Return to top](#introduction)


### Goal &lt;a id="goal"&gt;&lt;/a&gt;
Our goal is to understand the coupling between the voltage activity recorded from two brain areas during the auditory task. To do so, we compute the cross-covariance and coherence between the two electrodes. These coupling measures build upon the autocovariance, Fourier transform, and spectrum.


### Tools
Here you will develop an understanding for the cross-covariance and coherence measures. For the latter, we will explore and understand the Fourier transform and examine in detail the notion of phase. We also briefly discuss strategies to assess the coherence for a single trial of data.

+++

## Data Analysis &lt;a id="data-analysis"&gt;&lt;/a&gt;

+++

### Visual inspection &lt;a id="visual-inspection"&gt;&lt;/a&gt;

We begin our analysis by visualizing the ECoG data. To do so, let's load the ECoG data into Python and plot the data from the first electrode (variable `E1`) and second electrode (variable `E2`) versus time (variable `t`) for the first trial.

We begin by loading the data:

```{code-cell} ipython3
data = loadmat('ECoG-1.mat')
</code></pre></div></div>

<p>To understand the outcome of issuing this command, let’s examine the variable <code class="language-plaintext highlighter-rouge">data</code> now present in the workspace.  This variable is a <em>dictionary</em> variable (execute <code class="language-plaintext highlighter-rouge">type(data)</code> and the result should be <code class="language-plaintext highlighter-rouge">dict</code>). To see the <em>keys</em> of a dictionary, use the <code class="language-plaintext highlighter-rouge">keys()</code> method.</p>

<p>```{code-cell} ipython3
data.keys()</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
The keys that start and end with two underscores ( `__` ) are private and contain information about the MATLAB file. The variables that we are interested in here are `E1`, `E2`, and `t`. These correspond to the ECoG data recorded at the two electrodes (`E1` and `E2`) as well as a time axis (`t`). Let's extract these variables from the `data` dictionary.

```{code-cell} ipython3
E1 = data['E1']
E2 = data['E2']
t = data['t'][0]
</code></pre></div></div>

<div class="python-note">

  <p>In general, a single underscore at the beginning of a variable, function or method indicates that this object should be treated as <em>private</em>. Double underscores often indicate that Python will interpret this object with some special instructions. In both cases, for what we are doing, we can usually ignore an object that starts with an underscore.</p>

</div>

<p>Our collaborator tells us that the data from each electrode are organized as a matrix with dimensions <em>(Trials, Time)</em>. Let’s examine the shape of <code class="language-plaintext highlighter-rouge">E1</code>,</p>

<p>```{code-cell} ipython3
E1.shape</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
We observe that the data consist of 100 trials, each consisting of 500 data points.


&lt;div class="question"&gt;
    
**Q.** Is the shape of `E2` similar?  HINT: It should be!
    
&lt;/div&gt;


Let's now plot the data in the first trial from each electrode: &lt;a id="fig:traces"&gt;&lt;/a&gt;

```{code-cell} ipython3
f, a = subplots()
a.plot(t,E1[0,:], 'b')            # Plot the data from the first trial of one electrode,
a.plot(t,E2[0,:], 'r')            # ... and the first trial of the other electrode.
xlabel('Time [s]');
ylabel('Voltage [mV]');
fig, ax = {'traces': f}, {'traces': a}
</code></pre></div></div>

<p>Visual inspection of the data in this trial immediately suggests a dominant rhythmic activity occurs in each recording.</p>

<!-- #region -->
<div class="question">

  <p><strong>Q.</strong> Approximate the dominant rhythmic activity in each electrode by visual inspection of the figure. A simple procedure is to count the number of peaks in each signal, then divide by the total length of the recording (in this case, 1 s). Does each electrode exhibit approximately the same rhythms? Do you observe similar results in other trials?</p>

</div>

<p>+++</p>

<p>These techniques allow us to visualize the data one trial at a time. Doing so is often useful but can be time consuming, especially as the number of trials increases. Here we have 100 trials, and to visualize all of them in this way would require 100 plots. That’s not so bad, but there’s a better way. We can display the entire structure of the data across both time and trials as an image:</p>

<p>```{code-cell} ipython3
K = E1.shape[0]  #Get the number of trials,
f, a = subplots(figsize=(6, 6))  # Make a square axis
a.imshow(E1,  #… and show the image,
           extent=[min(t), max(t), K, 1],  # … with meaningful axes,
           aspect=’auto’)  # … and a nice aspect ratio
xlabel(‘Time [s]’)
ylabel(‘Trial #’);
title(‘All trials from E1’)
show()</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
The resulting image for the first electrode is shown in the figure above. Voltage (in color) is plotted as a function of time along the horizontal axis and trial number along the vertical axis. This allows us to visualize the voltage activity of the first electrode for all trials at once.

We notice that each trial exhibits rhythmic structure, which manifests in this image as repeating undulations of blue (low voltage), then red (high voltage) over time. We also observe variability in the alignment of these rhythms from trial to trial; from one trial to the next, the undulations appear not to align.

+++

&lt;div class="question"&gt;
    

**Q.** Display an image of the activity for the second electrode and compare it to the image from the first electrode in the figure above. How do the two compare?

    
&lt;/div&gt;

+++

Visual inspection of the ECoG data allows us to draw some preliminary conclusions. First, the data appear to be rhythmic, with a particularly strong oscillation near 8 Hz. That’s interesting but not the primary research objective. We would really like to understand whether the activity at the two electrodes is related. Many techniques exist to approach this problem, but let’s begin with the most basic: visual inspection. Let's examine the activity in the first four trials, and attempt to deduce whether a consistent relation exists between the two ECoG signals across trials.

```{code-cell} ipython3
f, a = subplots(4, 1, figsize=(12, 3*4))
for j in range(4):
    a[j].plot(t, E1[j], 'b')            # Plot the data from trial j of one electrode,
    a[j].plot(t, E2[j], 'r')            # ... and trial j of the other electrode.
    a[j].set_ylabel('Trial ' + str(j))
    
savefig('imgs/traces')
</code></pre></div></div>

<p>We notice in the first two trials that the ECoG activity from the two electrodes appears nearly out of phase (i.e., when the blue curve is near a peak, the red curve is near a trough). However, for the next two trials, activity from the two electrodes nearly overlaps. From this initial visual inspection of four trials, it’s difficult to conclude whether the ECoG activity at the two electrodes is interrelated; both electrodes display rhythmic activity across all trials, but the relation between these rhythms appears to change across trials: sometimes the activities overlap, and sometimes not.</p>

<p>+++</p>

<div class="question">

  <p><strong>Q.</strong> Repeat this analysis by examining additional trials, and by inspecting the activity images for each electrode. What conclusions can you make about the relations between the ECoG activity at the two electrodes? Are they related? Are they not related?</p>

</div>

<p>+++</p>

<p>Although visual inspection is a useful initial tool for analyzing data, assessing the relations between two electrodes across multiple trials is a difficult task. To go further, we employ a new data analysis tool that builds from the Fourier transform: the coherence.</p>

<p><a href="#top">Return to top</a>
<!-- #endregion --></p>

<p>+++</p>

<h3 id="autocovariance-and-cross-covariance-">Autocovariance and Cross-covariance <a id="Autocovariance-and-Cross-covariance"></a>
</h3>

<p>In <a href="../03">chapter 3</a>, we defined and applied the autocovariance to a single time series and found that this measure helped reveal dependent structure in the data. We could, of course, apply the autocovariance to each ECoG time series considered here. Let’s do so, with a small update to the autocovariance formula that utilizes the trial structure of these data. We define the trial-averaged autocovariance as,</p>

<p><span id="eq:ac" title="trial-averaged autocovariance"></span> 
<script type="math/tex">r_{xx}\big[L\big] = \frac{1}{K} \sum_{k=1}^K \frac{1}{N} \sum_{n=1}^{N-L} (x_{n+L,k} - \bar{x}_k) (x_{n,k} - \bar{x}_k) \, ,
\tag{Trial-averaged autocovariance}</script></p>

<p>where $x_{n,k}$ indicates the data at time index $n$ and trial $k,$ and $\overline x_k$ is the mean value of $x$ for trial $k$. Notice that we include a new term $ \frac{1}{K} \sum_{k=1}^K, $ which instructs us to sum over all trials the autocovariance computed for each trial, and then divide by the total number of trials $K.$  Let’s now compute and display the trial-averaged autocovariance for the first electrode in Python.<a id="fig:taac"></a></p>

<p>+++</p>

<div class="math-note">

  <p>Note: We could instead write the trial-averaged sample autocovariance because this equation uses the observed data to estimate the theoretical covariance that we would see if we kept repeating this experiment. However, this distinction is not essential to the discussion here.</p>

</div>

<p>```{code-cell} ipython3
dt = t[1] - t[0]  # Define the sampling interval.
K = E1.shape[0]  # Define the number of trials.
N = E1.shape[1]  # Define number of points in each trial.
ac = np.zeros([2 * N - 1])  # Declare empty vector for autocov.</p>

<p>for trial in E1:  # For each trial,
    x = trial - trial.mean()  # … subtract the mean,
    ac0 = 1 / N * np.correlate(x, x, ‘full’)  # … compute autocovar,
    ac += ac0 / K;  # … and add to total, scaled by 1/K.</p>

<p>lags = np.arange(-N + 1, N)  # Create a lag axis,
plot(lags * dt, ac)  # … and plot the result.
xlim([-0.2, 0.2])
xlabel(‘Lag [s]’)
ylabel(‘Autocovariance’);
title(‘Trial averaged autocovariance’)
savefig(‘imgs/taac’)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;div class="question"&gt;
    
**Q.** Consider the results for the trial-averaged autocovariance plotted above. What do these results suggest about the rhythmic structure in these data?

**A:** The trial-averaged autocovariance helps characterize the rhythmic activity at this electrode. Visual inspection of this figure reveals three large positive peaks. The largest peak occurs at a lag of 0 s, as expected; the signal matches itself at zero lag. The two other peaks occur at lags of approximately $\pm 0.125$ s. These peaks reveal that the data, and a version of the data shifted by +0.125 s or -0.125 s, are a good match. Notice that a shift of $\pm 0.125$ s is consistent with periodic activity of approximate frequency 1/(0.125 s) = 8 Hz. For example, imagine a sinusoid of frequency 8 Hz; if we shift the sinusoid by its period (0.125 s) and compare it to the original (unshifted) sinusoid, the match will be excellent. Our data are more complicated than a simple sinusoid, but our visual inspection of the [voltage traces](#fig:traces)&lt;span class="fig"&gt;&lt;sup&gt;fig&lt;/sup&gt;&lt;img src="imgs/5-1.png"&gt;&lt;/span&gt; did reveal a dominant 8 Hz rhythm consistent with these autocovariance results.
    
&lt;/div&gt;

+++

&lt;div class="question"&gt;
    
**Q.** Repeat the analysis to compute the trial-averaged autocovariance for the second electrode. What do you find? How do the trial-averaged autocovariances for the two electrodes compare?
    
&lt;/div&gt;

+++

The trial-averaged autocovariance results for each electrode are interesting, but our primary scientific question for these data is whether dependent structure exists *between* the ECoG activity recorded from the two electrodes. In other words, are the time series recorded from the two electrodes coupled? Many tools exist to characterize coupling between time series, and in this module we focus on two such tools.

The first is the **cross-covariance**, $r_{xy}\big[L\big]$, an extension of the autocovariance to include two time series, defined as,

&lt;span id="eq:xc" title="Cross-covariance"&gt;
$$
r_{xy}\big[L\big] = \frac{1}{N} \sum_{n=1}^{N-L} (x_{n+L} - \bar{x}) (y_{n} - \bar{y}) \, ,
$$
&lt;/span&gt;

where $x$ and $y$ are two time series with time index $n$.  Notice what we've done; compared to the autocovarance defined in [chapter 3](../03),&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="../03/imgs/eq3-3.png"&gt;&lt;/span&gt; the cross-covariance formula simply replaces the $x$'s in the second term in parentheses with $y$'s.

The intuition for understanding the cross-covariance is similar to that for the autocovariance (see [chapter 3](../03)). To calculate the cross-covariance, we multiply $y$ with $x$ shifted in time by lag $L$, as illustrated here:

&lt;img src="imgs/cartoon_xc.png" style="width: 90%; max-width: 600px"&gt;

Here we show a cartoon representation of the cross-covariance between two time series $x$ and $y$. Data $x$ and $y$ are visualized as one-dimensional vectors, $x$ in black and $y$ in blue. The cross-covariance at (b) lag 0, (c) lag 1, and (d) lag 2 requires different alignments between the two vectors. To compute the cross-covariance at each lag, we multiply the overlapping elements of the two vectors, and sum the product. Non-overlapping elements are not included in the computation.

The cross-covariance is large at lag $L$ if the two shifted time series $x$ and $y$ match. If we’re interested in determining the coupling between $x$ and $y$, finding these matches could be particularly useful. To illustrate an application of the cross-covariance, let’s compute it between the two electrodes during the first trial of the ECoG data: &lt;a id="fig:xc_1"&gt;&lt;/a&gt;

```{code-cell} ipython3
x = E1[0,:] - np.mean(E1[0,:])  # Define one time series,
y = E2[0,:] - np.mean(E2[0,:])  # ... and another.
xc=1/N*np.correlate(x,y,2)  # ... and compute their cross covariance.
lags = np.arange(-N+1,N)  # Create a lag axis,
plot(lags*dt,xc)  # ... and plot the cross covariance vs lags in time.

# Prettify
xlim([-0.2, 0.2])
xlabel('Lag [s]')
ylabel('Cross covariance');
title('Cross covariance between two electrodes during the first trial')
savefig('imgs/xc_1')
</code></pre></div></div>

<p>Notice that we subtract the mean from each electrode in defining <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> before computing the cross-covariance using the Python function <code class="language-plaintext highlighter-rouge">correlate</code> from the <code class="language-plaintext highlighter-rouge">numpy</code> package. In this case, we supply the <code class="language-plaintext highlighter-rouge">correlate</code> function with three inputs, beginning with the two time series, <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>, and setting the <code class="language-plaintext highlighter-rouge">mode</code> to 2, which tells the function to compute the correlation over the entire extent both vectors.</p>

<p>+++</p>

<div class="question">

  <p><strong>Q.</strong> Examine the cross-covariance between the ECoG data from the two electrodes in the first trial. What do you observe? At what lags are the largest and smallest values of the cross-covariance? How do these results compare to the <a href="#fig:taac">trial-averaged autocovariance</a>?<span class="sup">fig<img src="imgs/taac.png"></span> How do these results compare to the voltage traces from each electrode in the <a href="#fig:traces">first trial</a>?<span class="sup">fig<img src="imgs/traces.png"></span></p>

</div>

<p>+++</p>

<p>Like the <a href="#fig:taac">trial-averaged autocovariance for a single electrode</a>,<span class="sup">fig<img src="imgs/taac.png"></span> the <a href="#fig:xc_1">cross-covariance between the two ECoG electrodes</a><span class="fig"><sup>fig</sup><img src="imgs/xc_1.png"></span> in the first trial reveals periodic variations. To understand the structure of this cross-covariance, let’s return to the voltage traces from the two electrodes in this trial,</p>

<p>```{code-cell} ipython3
fig[‘traces’]</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
The largest peak in the cross-covariance occurs near a lag of 0.04 s. Now, imagine shifting the blue time series (corresponding to electrode 1) in this figure by 0.04 s to the left. Doing so, we find that the red and blue traces approximately match; at this lag, when one time series is positive, so is the other, and when one time series is negative, so is the other. Because of this strong match, the cross-covariance is large: i.e. the sum in [the cross-covariance equation](#eq:xc)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src='imgs/eq5-2.png'&gt;&lt;/span&gt; at this lag involves many positive terms, so $r_{xy}\big[L\big]$ is a positive number. The largest trough in the cross-covariance occurs near a lag of approximately 0.02 s. To understand this feature, imagine shifting the blue time series in the figure above by 0.02 s to the right. After this shift, the red and blue time series match, but in a different way; when one voltage trace is positive, the other is negative, and vice versa.

+++

&lt;div class="question"&gt;
    
**Q.** Continue this exercise of comparing the cross-covariance with the voltage traces in the figure above. At what lags is the cross-covariance near zero? Can you explain these points in terms of shifted versions of the ECoG traces? Can you explain the repeated appearance of peaks (and troughs) at positive and negative lags in terms of shifted versions of the ECoG traces?
    
&lt;/div&gt;

+++

Let’s also define the *trial-averaged cross-covariance*. The formula is similar to the [trial-averaged autocovariance](#eq:ac):&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eq5-1.png"&gt;&lt;/span&gt;

$$
r_{xy}\big[L\big] = \frac{1}{K} \sum_{k=1}^K \frac{1}{N} \sum_{n=1}^{N-L} (x_{n+L,k} - \bar{x}_k) (y_{n,k} - \bar{y}_k) \, .
$$

&lt;a id="eq:taxc"&gt;&lt;/a&gt;
Notice that, compared to the trial-averaged autocovariance, we have replaced the $x$'s in the last term with $y$'s to compute the trial-averaged cross-covariance.  To implement the trial-averaged cross-covariance in Python, consider the following code.

For reference, let's also plot the **single-trial** cross-covariance for 4 trials,  
&lt;a id="fig:avg_xc"&gt;&lt;/a&gt;

```{code-cell} ipython3
XC = np.zeros([K, 2 * N - 1])  # Declare empty vector for cross cov.
for k in range(K):  # For each trial,
    x = E1[k] - E1[k].mean()  # ...get data from one electrode,
    y = E2[k] - E2[k].mean()  # ...and the other electrode,
    XC[k] = 1 / N * np.correlate(x, y, 'full')  # ...compute cross covariance.

f, (a1, a2) = subplots(2, 1, figsize=(12, 6), sharex=True, sharey=True)    
a1.plot(lags * dt, XC.mean(0))					# Plot cross covariance vs lags in time.
[a2.plot(lags * dt, XC[k]) for k in range(4)]  # Also, plot the single-trial cross-covariance for 4 trials

# Prettify
xlim([-0.2, 0.2])
ylim([-0.6, 0.6])
xlabel('Lag [s]')
a1.set_title('Trial-averaged cross covariance')
a2.set_title('Single-trial cross-covariance')
savefig('imgs/avg_xc')
show()
</code></pre></div></div>

<div class="python-note">

  <p>You may have noticed above or in previous chapters that we can write loops using a couple of different forms:</p>

  <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>for k in range(K):
    ...
</code></pre></div>  </div>

  <p>or</p>

  <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>[... for k in range(K)]
</code></pre></div>  </div>

  <p>The difference is largely stylistic, but the resulting datatype may be different. With the first method, we typically initialize an array with zeros and then replace the zeros with the value that we have computed. The result is whatever datatype we initialized. The second method will result in a list. A list can be converted to a different type or simply treated differently. In the code above, we can actually compute <code class="language-plaintext highlighter-rouge">XC</code> in a single line with the following:</p>

  <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>XC = [1 / N * np.correlate(x - x.mean(), y - y.mean(), 'full') for x, y in zip(E1, E2)]
</code></pre></div>  </div>

  <p>At this point <code class="language-plaintext highlighter-rouge">XC</code> is a list object. We can change it to a numpy array with <code class="language-plaintext highlighter-rouge">XC = np.array(XC)</code>. Admittedly, there is something satisfying about accomplishing a lot in a single line. However, it is importsnt to write code that is <em>readable</em>, or easy to understand for someone who is looking at it for the first time. There may be times when a single line is more appropriate, but it is not true in every circumstance.</p>

</div>

<p>+++</p>

<p>The implementation of the trial-averaged cross-covariance is similar to the implementation of the single-trial cross-covariance. The main difference is the inclusion of the <code class="language-plaintext highlighter-rouge">for</code> statement, which we use to compute and store the cross-covariance of each trial. We then average these results across trials using the <code class="language-plaintext highlighter-rouge">mean</code> command from the <code class="language-plaintext highlighter-rouge">numpy</code> package. The trial-averaged cross-covariance (and example single-trial cross-covariances) are plotted in the figure above.</p>

<p>+++</p>

<div class="question">

  <p><strong>Q.</strong> Compare the trial-averaged cross-covariance to the example single-trial cross-covariances. What differences and similarities do you notice between the two cross-covariances?</p>

  <p><strong>A.</strong> Perhaps the most striking difference between the two cross-covariances is their magnitude; the single-trial cross-covariances are much larger—approximately an order of magnitude—than the trial-averaged cross-covariance. To understand why this difference occurs, consider the impact of averaging the four example single-trial cross-covariances plotted in the figure above. At each lag, we find both positive and negtive cross-covariance values. We therefore expect that, upon averaging these values across trials, we will obtain a value near zero at each lag. In fact, that’s just what we find in the trial-averaged cross-covariance. Because the single-trial cross-covariance functions lack alignment across trials, the averaging procedure acts to cancel out the individual (large) fluctuations of each single-trial cross-covariance.</p>

  <p>We may therefore conclude the following. At the single-trial level we find strong cross-covariance that is periodic with period near 0.125 s (examples in the figure aove). However, we find much weaker trial-averaged cross-covariance; the cross-covariance structure that exists at the single-trial level does not persist when averaged across trials.</p>

  <p>Why are the prominent cross-covariance features in the single-trial analysis lost in the trial-averaged cross-covariance? We discuss this issue in more detail in the <a href="#summary">summary</a> below.</p>

</div>

<p><a href="#top">Return to top</a></p>

<p>+++</p>

<h3 id="trial-averaged-spectrum-">Trial-Averaged Spectrum <a id="Trial-Averaged-Spectrum"></a>
</h3>

<p>One goal of this module is to characterize the relations (if any) between the data recorded at the two ECoG electrodes. To do so, let’s review a vital tool in this characterization, the Fourier transform. We defined in <a href="../03">chapter 3</a> the Fourier transfom of a signal $x$; let’s repeat that definition here,</p>

<p><script type="math/tex">X_j = \sum_{n=1}^N x_n \exp(-2 \pi i \, f_j \, t_n) \, .</script>
<a id="eq:ftCh5"></a></p>

<p>Remember that $x_n$ is the data evaluated at time index $n$. For the ECoG data of interest here, we have 1 s of data sampled at 500 Hz; therefore $n$ ranges from 1 to $N=500$, and $t_n = \mathrm{dt} \, n$ denotes the discrete time steps, where $\mathrm{dt}$ is the sampling interval. The discrete frequencies are $f_j = j/T$, where $j={-N/2+1, -N/2+2, \ldots, N/2-1, N/2}$.  Replacing the expressions for $f_j$ and $t_n$ with their definitions and simplifying, we can rewrite the equation above as,</p>

<p><script type="math/tex">X_j = \sum_{n=1}^N x_n \exp(\frac{-2 \pi i}{N} j \, n) \, .</script>
<a id="eq:ftCh5_simp"></a></p>

<p>+++</p>

<p>In general, $X_j$ can be a complex quantity (i.e., the Fourier transform of $x_n$ can have both real and imaginary parts). We can therefore think of $X_j$ as residing in the two-dimensional complex plane:</p>

<p><img src="imgs/ex_complex_plane.png" style="max-width: 300px;"></p>

<p>Points in the complex plane can be specified in two coordinate systems: Cartesian coordinates (gray) or polar coordinates (orange). The <a href="https://en.wikipedia.org/wiki/Complex_plane" target="_blank" rel="noopener noreferrer">complex plane</a> contains the real part (horizontal axis) and imaginary part (vertical axis) of every point.</p>

<p>As you may remember from a geometry or calculus class, we can represent a point in the plane using another coordinate system: polar coordinates. In polar coordinates, we imagine connecting each point to the origin. The resulting line has a length, called the radius or amplitude, and forms an angle with the real axis, called the phase. Like the real and complex parts, the amplitude and phase uniquely specify each point (almost …) in the complex plane. These two coordinate systems are shown for an example point in the complex plane in the figure above.</p>

<p>Using polar coordinates, we can then express the complex quantity $X_j$ as,</p>

<p><a id="eq:x_polar"></a>
<script type="math/tex">X_j = A_j \exp(i \phi_j) \, ,</script></p>

<p>where $A_j$ is the amplitude and $\phi_j$ is the phase at frequency index $j$.  Notice that both the amplitude and phase are functions of frequency.  Remember that, to compute the spectrum, we multiple the Fourier transform of the data by its complex conjugate, and scale the result. The spectrum of $x_n$ then becomes,</p>

<p><a id="eq:8" title="Spectrum"></a>
<script type="math/tex">% <![CDATA[
\begin{align}
S_{xx, \, j} 	&= \frac{2 \mathrm{dt}^2}{T} X_j X^\ast_j \, , \\
		&= \frac{2 \mathrm{dt}^2}{T} \big(A_j \exp(i \phi_j) \big)  \big(A_j \exp(-i \phi_j) \big) \, ,
\end{align}
\tag{Spectrum} %]]></script></p>

<p>where, to compute the complex conjugate in the second term, we replace $i$ with $-i$.  The last expression simplifies rather nicely,</p>

<p><span id="eq:9" title="Simplified expression for the cross spectrum"></span>
<script type="math/tex">% <![CDATA[
\begin{align}
S_{xx, \, j}	&= \frac{2 \mathrm{dt}^2}{T} A_j^2  \exp(i \phi_j -i \phi_j) \, , \notag \\
		&= \frac{2 \mathrm{dt}^2}{T} A_j^2  \exp(0) \, , \notag \\
		&= \frac{2 \mathrm{dt}^2}{T} A_j^2 \, .
\end{align} %]]></script></p>

<p>This expression provides a new, and perhaps more direct, interpretation of the spectrum as proportional to the squared amplitude of the point $X_j$ in the complex plane. We can extend this simplified expression in one additional way to make explicit the trial structure of the ECoG data analyzed here. Because we possess multiple trials, and we assume that each trial represents an instantiation of the same underlying process, we average the spectra across trials to compute the <em>trial-averaged spectrum</em>,</p>

<p><span title="Trial-averaged spectrum"></span>
<script type="math/tex">% <![CDATA[
<S_{xx, \, j}> = \frac{2 \mathrm{dt}^2}{T} \frac{1}{K} \sum_{k=1}^K A_{j,k}^2 \, ,
\tag{Trial-averaged spectrum} %]]></script></p>

<p>where $k$ indicates the trial number, $K$ the total number of trials, and $A_{j,k}$ the amplitude of the signal at frequency index $j$ and trial index $k$.  Notice how we implement the trial averaging: we simply average the squared amplitude at frequency index $j$ across the $K$ trials.  We use the angular brackets ($&lt; \, &gt;$) to denote that the spectrum ($S_{xx, \, j}$) has been averaged across trials. We can compute the trial-averaged spectrum in Python,</p>

<p><a id="fig:trial_avg_spectrum"></a></p>

<p>```{code-cell} ipython3
T = t[-1]  # Get the total time of the recording.
N = E1.shape[1]  # Determine the number of sample points per trial
scale = 2 * dt**2 / T  # Compute the scaling constant</p>

<h1 id="compute-the-fourier-transform-for-each-trial">Compute the Fourier transform for each trial</h1>
<p>xf = np.array([rfft(x - x.mean()) for x in E1])  # … in E1
yf = np.array([rfft(y - y.mean()) for y in E2])  # … and in E2</p>

<h1 id="compute-the-spectra-1">Compute the spectra</h1>
<p>Sxx = scale * (xf * xf.conj())  # Spectrum of E1 trials
Syy = scale * (yf * yf.conj())  # … and E2 trials
Sxy = scale * (xf * yf.conj())  # … and the cross spectrum</p>

<p>f = rfftfreq(N, dt)  # Define the frequency axis</p>

<h1 id="plot-the-average-spectrum-over-trials-in-decibels-vs-frequency">Plot the average spectrum over trials in decibels vs frequency</h1>
<p>plot(f, 10 * np.log10(Sxx.mean(0).real), lw=3, label=’Trial-averaged spectrum’)</p>
<h1 id="-and-the-spectrum-from-the-first-trial-for-reference">… and the spectrum from the first trial for reference</h1>
<p>plot(f, 10 * np.log10(Sxx[0].real), ‘k’, label=’Single-trial spectrum’)</p>

<h1 id="prettify">Prettify</h1>
<p>xlim([0, 100])  # … in select frequency range,
ylim([-50, 0])  # … in select power range,
xlabel(‘Frequency [Hz]’)  # … with axes labelled.
ylabel(‘Power [ mV^2/Hz]’)
title(‘Trial-averaged spectrum’)
legend()
savefig(‘imgs/trial_avg_spectrum’)
show()</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;div class="question"&gt;
    
**Q:** Are the terms frequency resolution, Nyquist frequency, and decibel familiar to you? Can you define each in words and equations?
**A:** If not, we recommend reviewing the case study in [chapter 3](../03).
    
&lt;/div&gt;

+++

The resulting trial-averaged spectrum is shown in the figure above. Compared to the example spectrum from a single trial, the variability is greatly reduced. By reducing the variability in this way, interesting structure in the data may become more apparent.

+++

&lt;div class="question"&gt;
    
**Q.**  Upon examining the trial-averaged spectrum from one electrode, what additional conclusions can you now make about the data beyond visual inspection of the voltage traces? Repeat this computation of the trial-averaged spectrum for the second electrode. What do you find?  *Hint*: The 8 Hz peak is obvious and consistent with our visual inspection of the data. Do you notice any other (smaller) peaks in the trial-averaged spectrum?
    
&lt;/div&gt;

+++

[Return to top](#introduction)

+++

# Introduction to the Coherence &lt;a class="anchor" id="sec:coherence"&gt;&lt;/a&gt;

+++

Coherence is a measure of association between two time series. Briefly:

&lt;div class="math-note"&gt;
    
Two signals are coherent at some frequency if there exists a constant phase relation between them at this frequency.
    
&lt;/div&gt;

To compute the coherence, we use the [simplified expression for the spectrum](#eq:9)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eq5-9.png"&gt;&lt;/span&gt; and an additional term, the cross-spectrum.

Consider two signals $x_{n,k}$ and $y_{n,k}$, with time index $n$ and trial index $k$. These signals have corresponding Fourier transforms $X_{j,k}$ and $Y_{j,k}$. Then the *trial-averaged cross-spectrum* between these two signals is

&lt;span id="eq:10" title="Trial averaged cross-spectrum"&gt;&lt;/span&gt;
$$
&lt;S_{xy,\, j}&gt; = \frac{2 \mathrm{dt}^2}{T} \frac{1}{K}\sum_{k=1}^K X_{j,k} Y^*_{j,k} \, ,
$$

where compared to [the spectrum](#eq:8)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eq5-8.png"&gt;&lt;/span&gt; we replace $X^*_j$ with $Y^*_j$ and include the average over the trial index $k$.  Let's modify and clean up this expression by using polar coordinates.  To do so, we'll first define,

$$
Y_{j,k} = B_{j,k} \exp(i \, \theta_{j,k}) \, ,
$$

where $B_{j,k}$ is the amplitude and $\theta_{j,k}$ is the phase at frequency index $j$ and trial index $k$ for the signal $y_{n,k}$. A similar expression exists for $X_{j,k}$, with amplitude $A_{j,k}$ and phase $\phi_{j,k}$. Then, replacing $X_{j,k}$ and $Y^*_{j,k}$ in [the trial-averaged cross-spectrum](#eq:9)&lt;span class="sup"&gt;eq&lt;img src="imgs/eq5-9.png"&gt;&lt;/span&gt; with their polar coordinate expressions, we find,

&lt;span id="eq:cross_spectrum" title="Cross spectrum"&gt;&lt;/span&gt;
$$
&lt;S_{xy,\, j}&gt; = \frac{2 \mathrm{dt}^2}{T} \frac{1}{K} \sum_{k=1}^K A_{j,k} B_{j,k} \exp \big( i \Phi_{j,k} \big) \, ,
\tag{Cross spectrum}
$$

where we have defined the *phase difference* between the two signals as $\Phi_{j,k} = \phi_{j,k} - \theta_{j,k}$. This equation is the trial-averaged cross spectrum of the two signals $x_{n,k}$ and $y_{n,k}$.  We note that the trial-averaged cross spectrum ($&lt;S_{xy,\, j}&gt;$) can be complex (i.e., may have nonzero real and imaginary parts).

At last we define the **coherence**,

&lt;span id="eq:cohr" title="Coherence"&gt;&lt;/span&gt;
$$
\kappa_{xy,\, j} = \frac{ \mid &lt;S_{xy,\, j}&gt; \mid }{ \sqrt{&lt;S_{xx, \, j}&gt;} \sqrt{&lt;S_{yy, \, j}&gt;}} \, ,
\tag{Coherence}
$$

where $\mid &lt;S_{xy,\, j}&gt; \mid$ indicates the magnitude of the trial-averaged cross spectrum.  In words, the coherence is the magnitude of the trial-averaged cross spectrum between the two signals at frequency index $j$ divided by the magnitude of the trial-averaged spectrum of each signal at frequency index $j$.

To further our understanding of the mathematical expression of the coherence, let's replace the trial-averaged spectra in the numerator and denominator with their corresponding expressions in polar coordinates,

&lt;span id="eq:cohr_ang" title="Coherence in polar coordinates"&gt;&lt;/span&gt;
$$
\kappa_{xy,\, j} = \frac { \biggr\lvert \sum\limits_{k=1}^K A_{j,k} B_{j,k} \exp \big( i \Phi_{j,k} \big) \biggr\rvert }
			       { \sqrt{\sum\limits_{k=1}^K A_{j,k}^2} \,  \sqrt{\sum\limits_{m=1}^K B_{j,m}^2} }
$$

This expression is complicated.  So, to gain some intuition for the behavior of $\kappa_{xy,\, j}$, let's make the simplifying assumption that at each frequency the amplitude is identical for both signals and all trials, that is, $A_{j,k} = B_{j,k} = C_j$.  Notice that, in using only the expression $C_j$ for the amplitude, we've eliminated the trial index $k$, and only preserved the frequency index $j$. With this simplifying assumption, our expression for the coherence becomes,

&lt;span id="eq:cohr_simp" title="Coherence (simplified)"&gt;&lt;/span&gt;
$$
\begin{align}
\kappa_{xy,\, j} &amp;= \frac { \biggr\lvert \sum\limits_{k=1}^K C_j \, C_j \exp \big( i \Phi_{j,k} \big) \biggr\rvert }
			         { \sqrt{\sum\limits_{k=1}^K C_j^2}  \sqrt{\sum\limits_{m=1}^K C_j^2} } \, , \notag \\
		    &amp;= \frac{ C_j^2 }{ C_j^2 } \frac{\biggr\lvert \sum\limits_{k=1}^K \exp \big( i \Phi_{j,k} \big) \biggr\rvert}{\sqrt{\sum\limits_{k=1}^K 1}  \sqrt{\sum\limits_{m=1}^K 1} } \, , \notag \\
		    &amp;= \frac{ 1 }{ K }\biggr\lvert \sum_{k=1}^K \exp \big( i \Phi_{j,k} \big) \biggr\rvert \, .
\end{align}
$$

Under the simplifying assumption that the amplitude is identical at each frequency for both signals and all trials, the coherence simplifies to the last equation in the expression above. In this special case, the expression for the coherence only involves the phase difference between the two signals averaged across trials; the amplitudes in the numerator and denominator have canceled out.

Now, let’s interpret the simplified expression for the coherence. To do so, we consider two scenarios.

+++

## Simple Scenario 1:  Phases align across trials &lt;a id="Simple_Scenario_1"&gt;&lt;/a&gt;

First, we assume that at a specific frequency index $j$, the two signals possess a *constant* phase difference across trials. Under this assumption, the phase difference in the first trial ($\Phi_{j,1}$) equals the phase difference in the second trial ($\Phi_{j,2}$), which equals the phase difference in the third trial ($\Phi_{j,3}$), and so on for all trials.  To denote this equivalence in the phase difference across trials, let's replace the symbol for the phase difference $\Phi_{j,k}$ with $\Phi_{j,0}$; here, we have replaced the subscript $k$ with the subscript $0$ to remind ourselves that the phase difference does not depend upon the choice of trial. Now consider the expression:

$$
\exp \big( i \Phi_{j,0} \big) \, . \notag
$$

This term defines a point in the complex plane with amplitude 1, which we can visualize as a vector leaving the origin at angle $\Phi_{j,0}$ to the real axis. Consider, for example, the leftmost plot in the figure below:
&lt;img src="imgs/ex_complex_plane_coherence_a.png"&gt;&lt;/img&gt;

In this cartoon illustration of the complex plane, we plot the phase difference for each trial (orange arrow). In this case, the phase difference is the same across all trials.

The summation of these terms across trials then becomes,

$$
\sum_{k=1}^K \exp \big( i \Phi_{j,0} \big) \, . \notag
$$

This expression defines a sum of vectors in the complex plane, each of radius 1 (indicated by the blue circle in the figure). Because the phase difference is the same for each trial, these vectors point in the same direction for each trial. Then by summing up these vectors end to end across trials, we produce a long vector in the complex plane that terminates far from the origin, as shown in the righmost panel of the figure above.

+++

&lt;div class="question"&gt;
    
**Q:** How long is the summed vector in this case?


**A:** We add $K$ vectors (one for each trial) each of length 1, and each pointing in the same direction ($\Phi_{j,0}$).  So the total length of the vector (i.e., the total distance from the origin to the termination point of the summed vector) is $K$.
    
&lt;/div&gt;

+++

The [coherence](#eq:cohr_simp)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eqcohr_simp.png"&gt;&lt;/span&gt; is this vector length, divided by $K$, so we conclude in this case that,

$$
\kappa_{xy,\, j} = 1 \, , \notag
$$

which indicates strong coherence between the two signals.  The strong coherence in this case results from the constant phase relationship between the two signals across trials at frequency index $j$.

+++

&lt;div class="question"&gt;
    
**Q:** Does the conclusion $\kappa_{xy,\, j} = 1$ depend upon the value of the phase difference $\Phi_{j,0}$?  For example, does this result require that the phase difference between the two signals in each trial ($\Phi_{j,0}$) equal $0$, or $\pi/4$, or $\pi$?
    
&lt;/div&gt;


[Return to top](#top)

+++

## Simple Scenario 2: Phases are random across trials &lt;a id="Simple_Scenario_2"&gt;&lt;/a&gt; 

As a second scenario, consider another specific frequency $j$ in which the two signals have a random phase difference in each trial. In this case, the phase difference can assume any value between $0$ and $2\pi$ for each trial. To visualize this, let’s imagine the phase differences in the complex plane; in this scenario, the vectors point in different (random) directions from trial to trial:

&lt;img src="imgs/ex_complex_plane_coherence_b.png"&gt;&lt;/img&gt;

+++

&lt;div class="question"&gt;
    
**Q:** Consider the sum of these vectors end to end in the complex plane, plotted in the rightmost panel of the figure above. What is the approximate length of this summed vector across trials?


**A:** We expect the length of this vector to be small. Because the angles lack organization from trial to trial, the vectors are equally likely to point in any direction. Therefore, when we sum these vectors across trials, the length fails to accumulate in any particular direction.
    
&lt;/div&gt;

+++

Under the simplifying assumption that the amplitude is identical at this frequency for both signals and all trials, the [coherence](#eq:cohr_simp)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eqcohr_simp.png"&gt;&lt;/span&gt; is this summed vector length, divided by $K$. Our visual inspection of the cartoon in the figure above (rightmost panel) suggests that this summed vector length will be small. Therefore, for this scenario we conclude that,

$$
\kappa_{xy,\, j} \approx 0 \, , \notag
$$

which indicates weak coherence between the two signals.  The weak coherence in this case results from the random phase relationship over trials between the two signals.

+++

# Summary of the coherence &lt;a id="Summary_of_the_coherence"&gt;&lt;/a&gt;

These two examples illustrate in simplified scenarios the behavior of the coherence. To summarize, the [coherence](#eq:cohr)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eqcohr.png"&gt;&lt;/span&gt; is a measure of the relationship between $x$ and $y$ at the same frequency.  The coherence ranges between 0 and 1,

$$
0 \leq \kappa_{xy,\, j}  \leq 1 \, , \notag
$$

in which:
- $0$ indicates no coherence between signals $x$ and $y$ at frequency index $j$, and
- 1 indicates strong strong coherence between signals $x$ and $y$ at frequency index $j$.

+++

&lt;div class="python-note"&gt;
    
The coherence is a measure of the phase consistency between two signals at frequency index $j$ across trials.
    
&lt;/div&gt;

+++

We note that because computing the coherence requires the Fourier transform, the notions of frequency resolution and Nyquist frequency are identical to those for the spectrum. In other words, the frequency resolution of the coherence is $1/T$, and the Nyquist frequency is half of the sampling frequency; see [chapter 3](../03) for details.

+++

&lt;div class="question"&gt;
    
**Q.** What are the units of the coherence?
Hint: Consider &lt;a href="#eq:cohr" class="thumb"&gt;this equation&lt;img src="imgs/eqcohr.png"&gt;&lt;/a&gt; for coherence and the units of the terms in the numerator and denominator. You should find that the coherence is unitless.
    
&lt;/div&gt;

[Return to top](#introduction)
***

+++

## Cross-Covariance and Cross-Spectrum &lt;a id="cc_and_cs"&gt;&lt;/a&gt;

Although we defined the [cross-spectrum](#eq:9)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eq5-9.png"&gt;&lt;/span&gt; and used it to define the [coherence](#eq:cohr)&lt;span class="thumb"&gt;&lt;sup&gt;eq&lt;/sup&gt;&lt;img src="imgs/eqcohr.png"&gt;&lt;/span&gt;, the cross-spectrum may appear somewhat unmotivated. Fortunately, there is additional insight to be gained. We show in a [supplement](../03#supplements) at the end of chapter 3 that the spectrum is the Fourier transform of the autocovariance. Conceptually, the spectrum and autocovariance provide a frequency domain and time domain measure of a signal’s rhythms, respectively. In the same way, the cross-spectrum and cross-covariance are partners.

+++

&lt;div class="math-note"&gt;
    
The cross-spectrum is the Fourier transform of the cross-covariance.
    
&lt;/div&gt;

+++

The cross-spectrum and cross-covariance form a Fourier transform pair. The cross-spectrum is a frequency domain measure of coupling, while the cross-covariance is a time domain measure of coupling. To move back and forth between these two measures, we use the Fourier transform. In practice, we rarely examine the cross-spectrum directly; it’s a complex quantity and so requires two dimensions (i.e., the complex plane) to visualize. However, the cross-spectrum is fundamental to the coherence, so in that sense it’s an important actor in the analysis.

+++

## Computing the Coherence &lt;a id="computing_coherence"&gt;&lt;/a&gt;
With that introduction, we are now equipped to compute the coherence. We expect the coherence to reveal the frequencies at which the two ECoG signals exhibit a constant phase relation across trials.

+++

&lt;div class="question"&gt;
    
**Q.** Before we compute the coherence, hypothesize whether you expect to observe coherence between the two ECoG signals. If so, at what frequencies? Your hypothesis should be based on the previous visual analysis and spectral analysis of these data (see, for example, &lt;a href="#fig:traces" class="fig"&gt;this figure&lt;img src="imgs/traces.png"&gt;&lt;/a&gt; and &lt;a href="#fig:trial_avg_spectrum" class="fig"&gt;this figure&lt;img src="imgs/trial_avg_spectrum.png"&gt;&lt;/a&gt;).
    
&lt;/div&gt;

+++

&lt;div class="question"&gt;
    
**Q.** To plot the coherence versus frequency, we must identify the frequency resolution and Nyquist frequency appropriate for the analysis of the ECoG data. What are they?
    
&lt;/div&gt;

+++

There are a variety of alternatives to compute the coherence. To start, let’s compute the coherence by hand. The reason for doing so is that we can implement the preceding mathematical expressions and in that way gain more understanding of their features. Here’s the Python code&lt;a id="fig:cohr"&gt;&lt;/a&gt;:

```{code-cell} ipython3
# Compute the Fourier transforms
xf = np.array([rfft(x - x.mean()) for x in E1])  # ... for each trial in E1
yf = np.array([rfft(y - y.mean()) for y in E2])  # ... and each trial in E2

# Compute the spectra
Sxx = scale * (xf * xf.conj()).mean(0)  # Spectrum of E1 trials
Syy = scale * (yf * yf.conj()).mean(0)  # ... and E2 trials
Sxy = scale * (xf * yf.conj()).mean(0)  # ... and the cross spectrum

# Compute the coherence.
cohr = abs(Sxy) / (np.sqrt(Sxx) * np.sqrt(Syy))

f = rfftfreq(N, dt)  # Define a frequency axis.
plot(f, cohr.real)  # Plot coherence vs frequency,
xlim([0, 50])  # ... in a chosen frequency range,
ylim([0, 1])  # ... with y-axis scaled,
xlabel('Frequency [Hz]')  # ... and with axes labeled.
ylabel('Coherence')
title('Coherence between two electrodes')
show()
</code></pre></div></div>

<div class="question">

  <p><strong>Q.</strong> That’s quite a bit of code. Look through it line by line, and confirm that each step makes sense. Can you identify the calculation of the cross-spectrum? of the trial averaging?</p>

</div>

<p>+++</p>

<div class="question">

  <p><strong>Q:</strong> Consider the coherence between the two ECoG electrodes plotted in the figure above. At what frequencies do strong coherences appear? How do these frequencies compare to the trial-averaged spectra, shown for one electrode in <span class="fig"><a href="#fig:trial_avg_spectrum">this figure</a><img src="imgs/trial_avg_spectrum.png"></span>?</p>

  <p><strong>A:</strong> The coherence measures the phase consistency at a chosen frequency between two signals across trials. For the ECoG data, both electrodes possess trial-averaged spectra with similar features: a large peak near 8 Hz and a smaller peak near 24 Hz. However, the coherence between the two ECoG signals reveals a peak only at 24 Hz. We conclude that the two ECoG signals both exhibit a dominant oscillation at 8 Hz, yet this rhythm is not coherent across trials; only the smaller-amplitude rhythm at 24 Hz is coherent between the two electrodes.</p>

</div>

<p>+++</p>

<h2 id="visualizing-the-phase-difference-across-trials-">Visualizing the Phase Difference across Trials <a id="Visualizing_the_Phase_Difference"></a>
</h2>

<p>+++</p>

<p>The coherence results suggest for the two ECoG recordings a constant phase relation across trials at 24 Hz and a random phase relation across trials at 8 Hz. To further explore these relations, let’s visualize the distribution of phase differences at the two frequencies, as implemented in the following Python code:</p>

<p>```{code-cell} ipython3
j8 = np.where(f==8)[0][0]  # Determine index j for frequency 8 Hz.
j24 = np.where(f==24)[0][0]  # Determine index j for frequency 24 Hz.</p>

<p>phi8 = np.zeros(K)  # Variables to hold phase differences.
phi24 = np.zeros(K)</p>

<p>for k in range(K):  # For each trial, compute the cross spectrum. 
    x = E1[k] - np.mean(E1[k])  # Get the data from each electrode,
    y = E2[k] - np.mean(E2[k,:])
    xf = rfft(x - np.mean(x))  # … compute the Fourier transform,
    yf = rfft(y - np.mean(y))
    Sxy = 2 * dt**2 / T * (xf * np.conj(yf))  # … and the cross-spectrum,
    phi8[k] = np.angle(Sxy[j8])  # … and the phases.
    phi24[k] = np.angle(Sxy[j24])</p>

<p>_, (a1, a2) = subplots(1, 2, sharey=True, sharex=True)  # Plot the distributions of phases.
a1.hist(phi8, bins=20, range=[-np.pi, np.pi])
a2.hist(phi24, bins=20, range=[-np.pi, np.pi])</p>

<h1 id="prettify-1">Prettify</h1>
<p>ylim([0, 40])
a1.set_ylabel(‘Counts’)
a1.set_xlabel(‘Phase’);
a1.set_title(‘Angles at 8 Hz’)</p>

<p>a2.set_title(‘Angles at 24 Hz’)
a2.set_xlabel(‘Phase’);
```</p>

<p>Again, we’re encountering quite a bit of Python code. Fortunately, large chunks of this code are familiar. We reuse useful quantities, like the number of trials (<code class="language-plaintext highlighter-rouge">K</code>) and the frequency axis (<code class="language-plaintext highlighter-rouge">f</code>). Then, within the frequency axis variable (<code class="language-plaintext highlighter-rouge">f</code>), we use the function <code class="language-plaintext highlighter-rouge">np.where</code> to identify the indices corresponding to a frequency of 8 Hz and a frequency of 24 Hz. For each trial, we then compute the cross-spectrum (<code class="language-plaintext highlighter-rouge">Sxy</code>). The cross-spectrum is a complex quantity at each frequency, and we identify the angle in the complex plane corresponding to the frequencies 8 Hz and 24 Hz using the Python function <code class="language-plaintext highlighter-rouge">np.angle</code>. We store these results in two vectors, <code class="language-plaintext highlighter-rouge">phi8</code> and <code class="language-plaintext highlighter-rouge">phi24</code>.</p>

<p>To summarize the results, we plot a histogram of the phase differences. We divide the phase axis into 20 bins of equal size from 0 to 2$\pi$ radians, or equivalently, 0 to 360 degrees. At 8 Hz, we observe that phase differences appear in all angular intervals; notice that the number of phase differences located in each angular interval remains small, typically less than 10. At 24 Hz, the angular differences concentrate near 0 degrees; all of the angles lie between  approximately 60 and 60 degrees. This visualization is consistent with the strong coherence at 24 Hz, indicative of a consistent phase difference across trials between the two electrodes.</p>

<p>+++</p>

<div class="question">

  <p><strong>Q.</strong> Compute and display the distribution of phase differences at other frequencies. What do you find? Are these results consistent with the <a href="#fig:cohr">coherence</a><span class="fig"><sup>fig</sup><img src="imgs/cohr.png"></span>?</p>

</div>

<p>+++</p>

<h2 id="single-trial-coherence-">Single-Trial Coherence <a id="single_trial_coherence"></a>
</h2>

<p>We have emphasized that coherence is a measure of phase consistency between two signals at some frequency <em>across trials</em>. This type of analysis is appropriate in many instances in which data are collected in a trial structure. However, we might also be interested in computing the coherence between two signals recorded in a single observation or trial.</p>

<p>+++</p>

<div class="question">

  <p><strong>Q:</strong> Is it possible? Can we compute the coherence between two signals for a single trial?</p>

</div>

<p>+++</p>

<p>To address this question, consider the <a href="#eq:cohr_ang">equation for the coherence written in polar coordinates</a><span class="thumb"><sup>eq</sup><img src="imgs/eqcohr_ang.png"></span>.  Remember that, in writing this equation, we have made no assumptions about the data;  instead, all we have done is express the complex quantities in polar coordinates.  Now consider this equation for the case in which we possess only one trial, so that $K=1$.  Then,</p>

<script type="math/tex; mode=display">\kappa_{xy,\, j} = \frac { \biggr\lvert A_{j,1} B_{j,1} \exp \big( i \Phi_{j,k} \big) \biggr\rvert }
			       { \sqrt{A_{j,1}^2}  \sqrt{B_{j,1}^2} }
		     = \biggr\lvert \exp \big( i \Phi_{j,k} \big) \biggr\rvert = 1 \, .</script>

<p>So, we find here perfect coherence ($\kappa_{xy,\, j}=1$) for any choice of signals $x$ and $y$ and for any frequency (index $j$).  For example, we could choose $x$ to be the price of a publicly traded stock (e.g., GE) and $y$ to be an ECoG recording, both sampled at 500 Hz for 1 s.  Even in this case, we will find perfect coherence between the two signals.</p>

<p>+++</p>

<div class="question">

  <p><strong>Q:</strong> Can we use an ECoG signal to predict the stock price of GE? If so, then we’re rich! How can any two arbitrary signals be perfectly coherent at all frequencies?</p>

</div>

<p>+++</p>

<p>The answer is that the coherence measure requires a trial structure. Recall that the coherence measures the phase consistency between two signals <em>across trials</em>. If only one trial is observed, then the two signals are trivially coherent; the two signals have some phase difference between 0 and 2$\pi$ and because we have no other trials with which to compare this difference, the two signals are “coherent.”</p>

<p>But what if we only collect one trial of data? We can still attempt to compute the coherence in (at least) two ways. First, we could divide the single trial of data into smaller intervals and then treat each interval as a trial. This approach can be effective if we believe the phase relation persists in time, and if we possess a long enough recording. Note that by dividing the data into smaller intervals, we impact the frequency resolution.</p>

<p>+++</p>

<div class="question">

  <p><strong>Q:</strong> Imagine we collect 10 s of ECoG data (sampling frequency 500 Hz) from two electrodes and would like to compute the coherence. To do so, we divide the data into ten nonoverlapping 1 s intervals, and treat each interval as a trial to compute the coherence. What is the frequency resolution of the coherence? If instead we divide the data into 100 nonoverlapping frequency intervals, what is the frequency resolution? In both cases, what is the Nyquist frequency?</p>

</div>

<p>+++</p>

<p>A second approach to compute the coherence from a single trial of data is to use the <a href="https://en.wikipedia.org/wiki/Multitaper" target="_blank" rel="noopener noreferrer">multitaper method</a>. In this case, each taper acts like a trial. Therefore, to acquire more trials for an accurate estimate of the coherence, we include more tapers. But, by increasing the number of tapers, we worsen the frequency resolution. Because the ECoG data of interest here consist of multiple trials, we do not focus on measures of single-trial coherence.</p>

<p>+++</p>

<h2 id="relation-between-statistical-modeling-and-coherence-">Relation between Statistical Modeling and Coherence <a id="Relation_between_Statistical_Modeling_and_Coherence"></a>
</h2>

<p>Before concluding the discussion of coherence, let’s briefly consider a complementary statistical modeling approach. In developing this statistical model, our goal is to capture the (linear) relation between two signals $x$ and $y$ observed simultaneously for multiple trials. We begin by proposing a statistical model that predicts one signal ($y$) as a linear function of the other ($x$):</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
y_n	&= \sum\limits_{m = -\infty}^{\infty} \beta_m x_{n-m} + \epsilon_n \, , \\
	&= (\beta \star x)\big[n\big] + \epsilon_n \, ,
\end{align*} %]]></script>

<p>where we express the predicted signal ($y_n$) as a function of $x_n$, coefficients $\beta_m$, and a Gaussian noise term $\epsilon_n$, and where $n$ is a discrete time index.  Notice that, in the first equation, the summation limits indicate that the predicted signal at time index $n$ may depend on $x$ at any past or future time.  The second equality above expresses the summed product of $\beta$ and $x$ as their convolution.  Taking the Fourier transform of both sides of this equation, and noting that convolution in the time domain is equivalent to multiplication in the frequency domain, we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
Y_j	&= \gamma_j X_j + \Upsilon_j \, ,
\end{align*} %]]></script>

<p>where $Y_j$ is the Fourier transform of $y_n$,
	$\gamma_j$ is the Fourier transform of $\beta_n$,
	$X_j$ is the Fourier transform of $x_n$,
	$\Upsilon_j$ is the Fourier transform of $\epsilon_n$,
and $j$ indicates a discrete frequency index.  Multiplying both sides of this equation by the complex conjugate of the Fourier transform of $x$,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
Y_j \, X_j^*	&= \gamma_j X_j \, X_j^*+ \Upsilon_j \, X_j^* \, ,
\end{align*} %]]></script>

<p>and averaging this result across the trials of data, we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
< Y_j \, X_j^* >	&= \gamma_j < X_j \, X_j^*> + < \Upsilon_j \, X_j^*> \, ,
\end{align*} %]]></script>

<p>where we have used the notation $&lt; \, &gt;$ to indicate the trial average.
Assuming that the noise term and signal $x$ are unrelated, their trial average is zero (i.e.,  $ &lt; \Upsilon_j \, X_j^*&gt; = 0$).  Solving for $\gamma_j$ we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\gamma_j  	&= \dfrac{< Y_j \, X_j^* >}{< X_j \, X_j^*>} \, , \notag \\
			&= \dfrac{< S_{xy,j} >}{< S_{xx,j} >} \, .
\end{align} %]]></script>

<p>Then, comparing this expression to the <a href="#eq:cohr">equation for coherence</a><span class="thumb"><sup>eq</sup><img src="imgs/eqcohr.png"></span> we find,</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
\kappa_{xy,\, j} =  \mid \gamma_j \mid \dfrac{\sqrt{<S_{xx, \, j}>}}{\sqrt{<S_{yy, \, j}>}} \, .
\end{align} %]]></script>

<p>We conclude that the coherence ($\kappa_{xy,\, j}$) is a scaled version of the frequency domain representation of the statistical model coefficients ($\gamma_j$) for predicting $y$ from $x$. We note that $\gamma_j$ is a complex quantity that allows us to model both the magnitude and phase of the relationship between $x$ and $y$.  The phase difference computed from the model and the coherence is the same as well.</p>

<p><a href="#top">Return to top</a></p>

<p>+++</p>

<h1 id="summary-">Summary <a id="summary"></a>
</h1>

<p>In this module, we analyzed ECoG data recorded from two electrodes during an auditory task. The task involved the repeated presentation of auditory stimuli, resulting in 100 trials of 1 s duration recorded simultaneously from the two electrodes. We began the analysis with visual inspection of individual trials and of all trials at once. Then, to assess the relations between the two recordings, we computed the cross-covariance. We discussed how the cross-covariance is an extension of the autocovariance, and found that the single-trial cross-covariance between the ECoG signals exhibited periodic structure, consistent with rhythmic coupling of period 0.125 s. However, the trial-averaged cross-covariance provided less evidence for consistent rhythmic coupling across trials. We then computed the trial-averaged spectrum and found a large peak near 8 Hz and a much smaller peak near 24 Hz.</p>

<p>To further assess the relation between the two electrodes, we computed the coherence. The coherence is strong (approaches 1) at a chosen frequency $f_0$ when there exists a constant phase relation at frequency $f_0$ between two electrodes over trials. We found a strong coherence between the two ECoG electrodes only at 24 Hz. We concluded that although both ECoG signals possessed dominant rhythms at 8 Hz, these rhythms were not coherent between the two electrodes. The strong coherence appeared only at the small-amplitude 24 Hz rhythm. Finally, we implemented a technique to visualize the distribution of phase differences between the two electrodes across trials, and provided some suggestions for how to compute the coherence for a single trial of data.</p>

<p>+++</p>

<div class="python-note">

  <p><strong>Caution!</strong> Large amplitude does not imply large coherence.</p>

</div>

<p>+++</p>

<p>In this example, only the coherence revealed the low-amplitude coupling at 24 Hz between the two ECoG electrodes. This coupling was not obvious in the single-trial or trial-averaged cross-covariance. In fact, the single-trial cross-covariance was deceiving; we found <a href="#fig:xc_1">strong single-trial cross-covariance</a><span class="fig"><sup>fig</sup><img src="imgs/xc_1.png"></span> with period 0.125 s, or 8 Hz, yet no coherence at 8 Hz.</p>

<p>To understand this discrepancy, consider two unrelated signals, each dominated by the same rhythm. By unrelated we mean that the signals do not communicate in any way. Yet both are rhythmic and happen to oscillate at the same frequency. If we compute the cross-covariance between these two unrelated signals, we will find periodic lags at which the two signals nearly overlap and the cross-covariance is large. The period of these cross-covariance peaks corresponds to the period of the common rhythm shared by the two signals. Here the periodic, large cross-covariance values occur because the two signals happen to both exhibit a similar rhythm, not because one signal influences the other.</p>

<p>This example illustrates a point of caution in the interpretation of cross-covariance results. Unrelated signals that happen to share a similar dominant rhythm will exhibit large periodic structure in the cross-covariance. One approach to defend against such cross-covariance results is to compute the trial-averaged cross-covariance. If two signals are unrelated—to one another and to the trial structure—then we do not expect similar cross-covariance functions across trials. Therefore, although each single-trial cross-covariance may have large values at some lags, their average across trials will be small. This is just what we found<a class="sup" href="#fig:avg_xc">fig<img src="imgs/avg_xc.png"></a> for the ECoG data examined here. We note that the unrelated 8 Hz signals, which dominate the ECoG activity at each electrode, mask the much smaller amplitude 24 Hz activity that is coupled between the two electrodes. The coupling at 24 Hz is not apparent in the trial-averaged cross-covariance<a href="#fig:avg_xc" class="sup">fig<img src="imgs/avg_xc.png"></a>. The coherence, which normalizes by the power at each frequency, uncovers this relation.</p>

<p>As is true for the Fourier transform and spectrum, there exists a vast literature on computing and interpreting the coherence. Some references for further reading include:</p>

<ul>
  <li>
    <p><a href="https://doi.org/10.1017/CBO9780511622762" target="_blank" rel="noopener noreferrer">Percival &amp; Walden, 1998</a></p>
  </li>
  <li>
    <p><a href="https://www.elsevier.com/books/spectral-analysis-and-time-series-two-volume-set/priestley/978-0-08-057055-6" target="_blank" rel="noopener noreferrer">Priestly, 1982</a></p>
  </li>
  <li>
    <p><a href="http://numerical.recipes/" target="_blank" rel="noopener noreferrer">Numerical recipes</a></p>
  </li>
</ul>

            </div>
            <div class="c-textbook__footer" id="textbook_footer">
              
<nav class="c-page__nav">
  

  
</nav>

              <footer>
  <p class="footer">This page was created by <a href="https://github.com/jupyter/jupyter-book/graphs/contributors" target="_blank" rel="noopener noreferrer">The Jupyter Book Community</a></p>
</footer>

            </div>

        </main>
</div>
      
    
  </body>
</html>
